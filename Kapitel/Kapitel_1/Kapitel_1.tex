\documentclass[
    ngerman,
    color=3b,
    % dark_mode,
    % load_common, % Loads a list of commonly used Packages
    summary,
    boxarc,
    % manual_term,
    % solution=true,
]{rubos-tuda-template} 
% Import all Packages from Main Preamble with relative Path
% \subimport*{../../}{preamble}
% Get Labels from Main Document using the xr-hyper Package
\externaldocument[ext:]{../../AuD-Zusammenfassung-2020}
% Set Graphics Path, so pictures load correctly
\graphicspath{{../../}}

\begin{document}
\section{Einführung}\label{1}\label{Einfuehrung}
\subsection{Probleme in der Informatik}\label{1.1}
Ein \fatsf{Problem}\index{Problem} im Sinne der Informatik:
\begin{itemize}
    \item Enthält Beschreibung der Eingabe
    \item Enthält Beschreibung der Ausgabe
    \item Gibt selbst \fatsf{keinen} Übergang von Ein und Ausgabe an
\end{itemize}
\begin{figure}[ht]
    \centering
    \includestandalone[width=.5\textwidth]{pictures/problem_informatik_modell/problem_informatik_modell}% 
    \caption{Modell Problem Informatik}
    \label{fig:modell-problem-informatik}
\end{figure}
z.B. Finde den kürzesten Weg zwischen 2 Orten\\
Eine \fatsf{Probleminstanz}\index{Probleminstanz} ist eine konkrete Eingabebelegung für die entsprechende Ausgabe gewünscht.\\
Für das obige Problem wäre das z.B. "`Was ist der kürzeste Weg vom Audimax in die Mensa?"'
\subsection{Definitionen für Algorithmen}\label{1.2}\label{Definitionen fuer Algorithmen}\index{Algorithmen}
\begin{definition}[Algorithmus]
    \enquote{Ein Algorithmus ist eine \fatsf{endliche Folge} von Rechenschritten, die eine \fatsf{Eingabe} in eine \fatsf{Ausgabe} umwandelt.}\footnote{Quelle: Cormen et al., 4. Auflage}
\end{definition}
\paragraph{Anforderungen an Algorithmen:}
\begin{description}[leftmargin=7cm, itemsep=1em]
    \item[Spezifizierung der Ein- und Ausgabe] \begin{itemize}
        \item Anzahl und Typen aller Elemente ist/sind definiert
    \end{itemize}
    \item[Eindeutigkeit]\index{Eindeutigkeit}\begin{itemize}
        \item Jeder Einzelschritt ist klar definiert und ausführbar
        \item Die Reihenfolge der Einzelschritte ist festgelegt.
    \end{itemize}
    \item[Endlichkeit]\index{Endlichkeit}\begin{itemize}
        \item Notation hat endliche Länge
    \end{itemize}
\end{description}
\paragraph{Eigenschaften von Algorithmen:}
\begin{description}[leftmargin=3.5cm]
    \item[Determiniertheit]\index{Determiniertheit} Für gleiche Eingabe folgt stets die gleiche Ausgabe (andere Zwischenzustände sind möglich)
    \item[Determinismus]\index{Determinismus} Für die gleiche Eingabe ist die Ausführung und Ausgabe stets identisch.
    \item[Terminierung]\index{Terminierung} Der Algorithmus läuft für jede endliche Eingabe nur endlich lange
    \item[Korrektheit]\index{Korrektheit} Der Algorithmus berechnet stets die spezifizierte Ausgabe (falls dieser terminiert).
    \item[Effizienz]\index{Effizienz} Sparsamkeit im Ressourcenverbrauch (Zeit, Speicher, Energie, ...)
\end{description}
\subsection{Definitionen für Datenstrukturen}\label{1.3}\label{Definitionen fuer Datenstrukturen}\index{Datenstrukturen}
\begin{definition}[Datenstruktur]
    \enquote{Eine Datenstruktur ist eine Methode,
    Daten \fatsf{abzuspeichern} und zu \fatsf{organisieren} sowie
    den \fatsf{Zugriff} auf die Daten und die \fatsf{Modifikation}
    der Daten zu erleichtern.}\footnote{Quelle: Cormen et al., 4. Auflage}
\end{definition}
\begin{wrapfigure}[5]{r}{.6\textwidth}
    \centering
    \includestandalone[width=.5\textwidth]{pictures/baum_beispiel/baum_beispiel}% 
    \caption{Beispiel Datenstruktur (Rot-Schwarz-Baum)}
    \label{fig:baum_beispiel}
\end{wrapfigure}
Datenstrukturen:\begin{itemize}
    \item Sind Organisationsformen für Daten
    \item Beinhalten Strukturbestandteile und Nutzerdaten (Payload)
\end{itemize}
z.B. \exthyperref[2.2]{Arrays}, \exthyperref[Verkettete Listen]{Listen}, \ldots
\vspace*{2cm}
\subsection{Pseudocode-Konventionen}\index{Pseudocode}
\begin{grayInfoBox}
    \begin{itemize}
        \item Blöcke werden durch Einrückungen hervorgehoben
        \item Blockkonstrukte sind "`\texttt{for x to y}"', "`\texttt{while}"', "`\texttt{repeat-until}"' und "`\texttt{if-else}"'
        \item Kommentare erhalten das Prädikat "`\texttt{//}"'
        \item "`\texttt{i = j = e}"' bedeutet, \texttt{i} und \texttt{j} erhalten den Wert von \texttt{e}
        \item Variablen sind immer lokal
        \item $A[i]$ bezeichnet das i-te Element im Array A
        \item $A[i..j]$ Array A im Bereich von $i-j$
        \item Attribute werden über einen "`\texttt{.}"' abgerufen
    \end{itemize}
\end{grayInfoBox}

\subsection{Weitere wichtige Definitionen}
\begin{definition}[short circuit evaluation (Kurzschlussauswertung)]\index{short circuit evaluation}
    Strategie, bei der die Auswertung, nachdem die \linebreak Gesamtlösung durch einen Teilausdruck eindeutig bestimmt wurde, abgebrochen wird.\\ 
    z.B.: \texttt{1+1==2 || 1/0==0}$\longrightarrow \texttt{true}$
\end{definition}
\begin{definition}[call-by-reference (Referenzparameter)]\index{call-by-reference}
    Übergeben von Referenz auf ein Objekt. Dadurch sind Änderungen an diesem innerhalb der Routine möglich.
\end{definition}
\begin{definition}[call-by-value (Wertparameter)]index{call-by-value}
    Übergeben einer Kopie des Objekts. Das ursprüngliche Objekt kann so nicht mehr verändert werden, jedoch die Kopie. Die referenzen bleiben beim Kopieren gleich\linebreak (z.B. bein Linked List)
\end{definition}
\clearpage
\end{document}